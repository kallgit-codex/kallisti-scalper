// Micro-Scalping Position Management
// FAST exits, tight stops, recovery mode

import { config } from "../config";

export interface Position {
  id: string;
  side: "Long" | "Short";
  entryPrice: number;
  entryTime: number;
  collateral: number;
  leverage: number;
  stopLoss: number;
  takeProfit: number;
  minProfitTarget: number;
  maxProfitTarget: number;
  inRecoveryMode?: boolean;
  recoveryStartTime?: number;
}

export interface PositionUpdate {
  shouldClose: boolean;
  reason?: string;
  exitPrice?: number;
  enteredRecovery?: boolean;
}

/**
 * Create new position
 */
export function createPosition(
  side: "Long" | "Short",
  entryPrice: number,
  collateral: number
): Position {
  const leverage = config.futures.leverage;
  const positionSize = collateral * leverage;
  
  // Calculate stops
  const initialStopPercent = config.strategy.initialStopPercent / 100;
  const stopLoss = side === "Long"
    ? entryPrice * (1 - initialStopPercent)
    : entryPrice * (1 + initialStopPercent);
  
  // Calculate TP based on percentage
  const targetPercent = config.strategy.targetProfitPercent / 100;
  const takeProfit = side === "Long"
    ? entryPrice * (1 + targetPercent)
    : entryPrice * (1 - targetPercent);
  
  return {
    id: `pos-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`,
    side,
    entryPrice,
    entryTime: Date.now(),
    collateral,
    leverage,
    stopLoss,
    takeProfit,
    minProfitTarget: config.strategy.minProfitDollars,
    maxProfitTarget: config.strategy.maxProfitDollars,
    status: "open" as const,
  };
}

/**
 * Enter recovery mode - widen stop, wait for bounce
 */
export function enterRecoveryMode(position: Position): Position {
  const recoveryPercent = config.strategy.recoveryStopPercent / 100;
  
  const recoveryStop = position.side === "Long"
    ? position.entryPrice * (1 - recoveryPercent)
    : position.entryPrice * (1 + recoveryPercent);
  
  return {
    ...position,
    stopLoss: recoveryStop,
    inRecoveryMode: true,
    recoveryStartTime: Date.now(),
  };
}

/**
 * Update position and check exit conditions
 */
export function updatePosition(
  position: Position,
  currentPrice: number
): PositionUpdate {
  const now = Date.now();
  const timeElapsed = (now - position.entryTime) / 1000; // SECONDS
  
  // Calculate P&L
  const positionSize = position.collateral * position.leverage;
  let pnlPercent: number;
  
  if (position.side === "Long") {
    pnlPercent = ((currentPrice - position.entryPrice) / position.entryPrice) * 100;
  } else {
    pnlPercent = ((position.entryPrice - currentPrice) / position.entryPrice) * 100;
  }
  
  const pnl = (pnlPercent / 100) * positionSize;
  
  // 1. Check max profit target (force exit)
  if (pnl >= position.maxProfitTarget) {
    return {
      shouldClose: true,
      reason: "profit-target",
      exitPrice: currentPrice,
    };
  }
  
  // 2. Check min profit target
  if (pnl >= position.minProfitTarget) {
    return {
      shouldClose: true,
      reason: "profit-target",
      exitPrice: currentPrice,
    };
  }
  
  // 3. Check stop loss (enter recovery if not already in it)
  if (position.side === "Long" && currentPrice <= position.stopLoss) {
    if (!position.inRecoveryMode) {
      // Enter recovery mode
      return {
        shouldClose: false,
        enteredRecovery: true,
      };
    } else {
      // Already in recovery, hit recovery stop
      return {
        shouldClose: true,
        reason: "recovery-stop",
        exitPrice: currentPrice,
      };
    }
  }
  
  if (position.side === "Short" && currentPrice >= position.stopLoss) {
    if (!position.inRecoveryMode) {
      // Enter recovery mode
      return {
        shouldClose: false,
        enteredRecovery: true,
      };
    } else {
      // Already in recovery, hit recovery stop
      return {
        shouldClose: true,
        reason: "recovery-stop",
        exitPrice: currentPrice,
      };
    }
  }
  
  // 4. In recovery mode - check if time expired
  if (position.inRecoveryMode) {
    const recoveryTime = (now - (position.recoveryStartTime || now)) / 1000;
    
    if (recoveryTime >= config.strategy.recoveryTimeSeconds) {
      // Recovery time expired
      if (pnl >= 0) {
        // Got back to breakeven or profit - exit
        return {
          shouldClose: true,
          reason: "recovery-success",
          exitPrice: currentPrice,
        };
      }
      // Still in loss after recovery time - force exit
      return {
        shouldClose: true,
        reason: "recovery-timeout",
        exitPrice: currentPrice,
      };
    }
  }
  
  // 5. Quick exit at breakeven if taking too long
  if (timeElapsed >= config.strategy.quickExitSeconds && pnl >= 0) {
    return {
      shouldClose: true,
      reason: "quick-exit-breakeven",
      exitPrice: currentPrice,
    };
  }
  
  // 6. Max time reached - FORCE EXIT
  if (timeElapsed >= config.strategy.maxTradeSeconds) {
    return {
      shouldClose: true,
      reason: pnl >= 0 ? "timeout-profit" : "timeout-loss",
      exitPrice: currentPrice,
    };
  }
  
  return {
    shouldClose: false,
  };
}

/**
 * Close position and calculate final P&L
 */
export function closePosition(
  position: Position,
  exitPrice: number,
  reason: string
): Position & { exitPrice: number; exitTime: number; pnl: number; reason: string } {
  const positionSize = position.collateral * position.leverage;
  
  let pnlPercent: number;
  if (position.side === "Long") {
    pnlPercent = ((exitPrice - position.entryPrice) / position.entryPrice) * 100;
  } else {
    pnlPercent = ((position.entryPrice - exitPrice) / position.entryPrice) * 100;
  }
  
  const pnl = (pnlPercent / 100) * positionSize;
  
  return {
    ...position,
    exitPrice,
    exitTime: Date.now(),
    pnl,
    status: "closed" as const,
    reason,
  };
}
